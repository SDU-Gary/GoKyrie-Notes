---
title: 2024计算机网络
draft: false
tags:
  - 校内课程笔记
  - 计算机基础
  - 计算机网络
---

<aside>
😀 这里就不写太详细了，只写考试重点会对应核心内容。上课预习建议看wiki的详细内容，这里仅供复习参考
</aside>

# 概论

## 1.计算机网络的定义，p2p

计算机网络的定义：将分散的具有独立功能的计算机系统，通过通信设备和线路连接起来，有功能完善的软件**实现资源共享和信息传递**的系统

P2P：peer-to-peer network对等网络，又称工作组，网络中每个计算机拥有相同的功能，**无主从之分，**每个计算机既可做服务器又可做工作站

## 2.网络硬件（广播，多播，单播，LAN，MAN，WAN，Internet，packet switching）

传输模式：

- 广播（broadcasting）：主机之间一对所有的通讯模式，所有主机可以接收所有消息（无论是否需要），可视为一种特殊的多播/组播。
- 多播/组播（multicasting）：主机间一对一组的通讯模式，同一组的主机可以接收此组内所有数据，网络中的交换机和路由器只向有需求者复制并转发所需数据。
- 单播（unicasting）：主机间一对一的通讯模式，网络中交换机和路由器只对数据转发而不复制。

网络尺度：

- 个域网（PAN）：允许设备围绕一个人进行通信，个人设备的互联；比如蓝牙。
- 局域网（LAN）：一种局部地区私有网，一般在建筑物大小范围，比如家庭，办公；局域网有三个特点：距离短，传输速率高，错误率低。
  
    局域网的组网方式分为有线和无线两种：
    
    1. 无线LAN：每个计算机有一个无线调制解调器和一个天线，用于通信。大多数情况下是和一个设备通信，这个设备被称为接入点（AP,Access Point）,无线路由器或者基站。这个设备主要负责中继无线计算机之间的数据包，还负责中继无线计算机和Internet之间的数据包。例如WIFI
    2. 有线LAN：大多数用铜线作为传输介质，也会用光纤。
       
        许多有线局域网的拓扑结构是以点到点链路为基础的，俗称以太网的IEEE 802.3是迄今为止最常见的一种有线局域网，每台计算机按照以太网协议规定的方式运行，通过一条点到点链路链接到一个交换机（switch），一台交换机有多个端口，每个端口连接一台计算机。交换机的工作是中继与之相连的计算机之间的数据包，根据数据包中的地址来确定这个数据包要发送到哪台计算机
    
- 城域网（MAN）：范围覆盖一个城市。例如城市内的有线电视网。
- 广域网（WAN）：跨域大范围地理区域，通常至少是一个国家，地区，甚至一个大陆
  
    广域网的任务是提供长距离通信，覆盖范围通常是几十到几千千米，**广域网是因特网的核心部分；局域网使用广播技术，广域网使用交换技术**
    

## 3.网络软件(协议protocol，层layer，接口Interface，service，差错/流量控制，面向连接和无连接，可靠和不可靠，服务与协议关系，OSI参考模型，TCP/IP参考模型)

### **协议层次结构**

协议层次：为了降低设计复杂性，采用互相叠加的层，每一层建立在下层的基础上，目的是为上层提供服务，具体细节对上层隐藏。

**层和协议的集合即称为网络体系结构（network architecture）**，一个特定的系统所使用的一组协议即称为**协议栈（protocol stack）。**

- 协议：通信双方就如何进行通信的一种约定。网络协议由语法，语义和同步三部分组成
- 接口：是同一节点内相邻两层间交换信息的连接点，是一个系统内部的规定。接口定义了下层向上层提供哪些原语操作和服务。
- 服务：指下层为紧相邻的上层提供的功能调用，由一组原语（primitive）构成的正式说明
- 对等实体：不同机器上构成相应层次的实体称为对等实体
  
    ![62B3rZd4HlfnjTX.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281642728.png)
    

协议与服务的关系:

1. 服务是指**某一层向它上一层提供的一组原语操作**，服务定义了该层打算代表其用户执行哪些操作，但是他不涉及如何实现这些操作，服务也会涉及到两层之间的接口，其中底层是服务提供者，而上层是服务的用户（上下层之间的联系）。
2. 协议是一组规则，用来规定**同一层上的对等体之间所交换的消息或者分组的格式和含义**。这些实体利用协议来实现他们的服务定义，他们可以自由的改变协议而不影响它提供给上层的服务（对等体之间的规范）。

### 差错控制:

**差错控制（Error Control）**：是在数字通信中利用编码方法对传输中产生的差错进行控制，以提高数字消息传输的准确性。

**流量控制（Flow Control）**：是指在发送端和接收端之间的点对点通信量的控制。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来的及接收。

**拥塞控制（Congestion Control）**：必须确保通信子网能够传送待传送的数据，是一个全局性的问题，涉及网络中所有的主机、路由器以及导致网络传输能力下降的所有因素。

### 面向连接和无连接

- **面向连接服务（connection-oriented service）**：通信双方必须**先建立连接，分配相应的资源（如缓冲区）**，以保证通信能够正常进行，传输结束后释放连接和所占用的资源（连接建立，数据传输，连接释放）。
- **无连接服务（connectionless service）**：通信前双方不需要先建立连接，需要发送数据时就直接发送，把每个带有目的地址的包（报文分组）传送到线路上，由系统选定路线进行传输，是一种**不可靠的服务**。

区别:

1. 面向连接的要求建立连接，因而没有传输的数据没有必要再标明传输的目的地址；而无连接的则对每个报文都由独立的目标地址.
2. 一般来说，面向连接的可靠性较高，协议相对复杂，传输的数据按照发送顺序到达；而无连接的可靠性较差，协议相对简单，常出现乱序，重复和丢失现象.

### 可靠与不可靠服务

可靠服务即**从来不丢失数据**的一种服务。一般情况下，可靠服务都要求接收方向发送方确认收到的每个报文；不可靠的服务则不会给发送方反馈任何确认消息，不保证数据不丢失。

- 可靠服务：是指网络具有纠错、检错、应答机制，能保证数据正常、可靠地传送到目的地。
- 不可靠服务：是指网络只是尽量正确、可靠地传送，但不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。

二者之所以同时存在，原因在于：

- 在给定的层次可靠通信并不总是可以使用的。
- 为了提高可靠服务而导致的固有延迟可能是不可接受的。

**需要注意**：面向连接的服务只是在发送发和接收方之间建立连接，它并不能保证发送的数据流能准确无误的按序到达接收方。**面向连接的服务同样分为可靠的面向连接服务和不可靠的面向连接服务**。其中，前者主要包括报文序列、字节流，后者如数字化语音。

### **OSI模型与TCP/IP模型**

OSI（Open System Interconnect）：开放式系统互联，一般都叫OSI参考模型。OSI模型分为七层，由低到高分别为：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。如下图和下表所示

![XxlTVkviHsY8AIn.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281642197.png)

TCP/IP协议划分了四层网络，自下而上分别为：

- 网络接入层/链路层：对应OSI参考模型中的物理层和数据链路层，负责监视数据在主机和网络之间的交换。该层主要有地址解析协议（ARP）工作
- 互联网/网际互联/网络层：对应OSI参考模型中的网络层，解决主机到主机的通信问题。该层通过重新赋予主机一个IP地址来完成对主机的寻址，负责数据包在多种网络中的路由。该层主要有网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）在工作
- 传输层：对应 OSI 参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。运行 TCP 和 UDP。
- 应用层：对应OSI参考模型的高层。
  
    ![v2-ec2d34bd1df8809b97a166010e87b05e_1440w.webp](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281642170.webp)
    
    ![Cx3TszBwolaH8Mk.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281642812.png)
    

## 4.802协议，网络标准化

IEEE 802中定义的服务和协议限定在OSI 模型的最低两层（即物理层和数据链路层）。事实上，IBBE 802 将OSI 的数据链路层分为两个子层，分别是逻辑链路控制（LLC，Logical Link Control）和介质访问控制（MAC，Media Access Control）。几种重要的802协议：

- 802.3：以太网介质访问控制协议（CSMA/CD）及物理层技术规范。
- 802.11：无线局域网的介质访问控制协议及物理层技术规范。
- 802.15：个域网协议（蓝牙、ZigBee）。
- 802.16：宽带无线网。

世界上有很多的网络生产商和供应商，他们都有自己的思维模式和行为方式，只有大家都遵守一些网络标准才能进行协调，相关的组织有：

- ISO 国际标准化组织
- 国际电信联盟 ITU
- 电气电子工程师协会 IEEE
- Internet 工程任务组 IETF
- Internet 研究任务组 IRTF

# 物理层

## 1.数据通信的理论基础（bandwidth,尼奎斯特定理，香农定理）

### 数据通信理论

每个给定的信道都有一定的数据传输能力，如何**描述和定义这种数据传输能力**是本节主要的关注点。信道的传输能力可以使用带宽和信道描述：

- **带宽（Bandwidth）**：在**传输中不会明显减弱的频率的宽度**，通常引用的带宽是指从零频率到使得接收能量保留一半的那个频率位置，是传输介质的一种物理属性。通常取决于介质的构成、厚度、电线或者光纤的长度;单位是赫兹。
- **信道**：信道是信号的传输媒介。信号在任何物理通道传输的过程中会有能量的损失，尤其是不同频率的信号损失程度不同；**频率越高的信号损失能量越多**。给定一个传输介质，频率高的一些信号成分无法传输到接收方（传输过程中消耗完了）。

信号在信道内传输时，**信号会包含一种或多种频率成分**。其中高于信道截止频率的频率成分将由于能量衰减过多而不能通过信道，通过信道的只能是低于截止频率的成分。传输过程中信号会发生变形，能否准确识别依赖于通信双方的约定（信号发送设备和信号接收设备）：通信双方需要根据能够传输过去的频率成分考虑合适的调制（编码）和解调（解码），即什么样的信号对应什么样的比特（组合）。

**信噪比（SNR）**：信号功率 S 与噪声功率 N 的比值，即为信噪比 S/N。

**分贝（dB）**：通常把信噪比表示成对数的形式 $10log_{10}(S/N)$，对数的取值单位称为分贝。信噪比为 100 可表示为 20dB。

### 尼奎斯特&香农定理(最大传输速率计算)

尼奎斯特定理：用来表示一个**有限带宽的无噪声信道**的最大数据传输率。尼奎斯特定理用于计算理想情况下的最大数据传输速率，即在没有噪声干扰的情况下。根据尼奎斯特定理，信道的最大数据传输速率可以通过以下公式计算：

$$
R_{max} = 2Blog_2(V)
$$

其中，$R_{max}$表示最大数据传输速率（单位为比特/秒），B表示信道的带宽（单位为赫兹），V表示**信号的离散级数**（即离散的幅度或相位级数）

尼奎斯特定理告诉我们，通过**增加信号的离散级数或者扩大信道的带宽**，可以提高信道的最大数据传输速率。

例如，如果一个无噪音话音信道（3400 Hz），采用二进制信号传输，V=2，最大速率不能超过`2×3400Hz=6800bps2×3400Hz=6800bps`。若V = 16，最大速率则可提高到 27200 bps.

1. 香农定理：用来表示**有噪声信道的最大数据传输率或容量**。香农定理用于计算在存在噪声干扰的情况下的最大数据传输速率。根据香农定理，最大数据传输速率可以通过以下公式计算：  
   
    $$
    C=Blog_2(1+S/N)
    $$
    
    其中，C表示最大数据传输速率（单位为比特/秒），B表示信道的带宽（单位为赫兹），S/N表示信号与噪声的比值（信噪比）。
    
    香农定理告诉我们，通过**增加信道的带宽或提高信号与噪声的比值**，可以提高信道的最大数据传输速率。
    
    例如，模拟电话系统中，话音信道信噪比的典型值为 30dB（或者说因为1dB=10lg⁡SN1dB=10lg*NS*​，所以SN=1000*NS*​=1000），那么最大数据传输速率为： C=3400×2(1+1000)≈33888bps*C*=3400×log2​(1+1000)≈33888bps。
    

## 2.有导向的传输介质

常见的有线传输介质如下：

- 磁介质：带宽良好，延迟高。
- 双绞线：将两根线绞在一起，噪音对他们的干扰是一样的，所以他们的**电压差不会改变**，通过电压差来表示信号。双绞线的工作方式有三种：
    1. 全双工：可以同时双向使用。
    2. 半双工：可以双向传输，但每一时刻只允许使用一个方向。
    3. 单工：只允许单向传输。
- 同轴电缆：带宽高，抗噪性好。
- 电力线
- 光纤：分为单模和多模两种。

## 3.PSTN电话系统（Modem调制解调（调幅，调频），ADSL，干线与复用（FDM，WDM，TDM），电路交换，分组交换，三种交换方式比较）

### 调制和编码

通信系统自下而上由**信道、信号、数据**三个概念组成。首先是信道，分为数字信道和模拟信道：

- **数字信道**：以数字脉冲形式（离散信号）传输数据的信道。
- **模拟信道**：以连续模拟信号形式传输数据的信道。

与信道相似，信号包括模拟信号和数字信号：

- **模拟信号**：时间上连续，包含无穷多个值。
- **数字信号**：时间上离散，仅包含有限数目的预定值。

数据也有模拟数据和数字数据组成，其中**数字数据**的传输过程有两种：

- **基带传输**：不调制，编码后的数字脉冲信号直接在信道上传送。
  
    > 例如以太网。
    > 
- **频带传输**：调制成模拟信号后再传送，接收方需要解调。
  
    > 例如通过电话模拟信道传输。
    > 

![6IRAy8VGKnDgS1J.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281643443.png)

具体组合情况:

![XN9jnThFOS4sp2R.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281643877.png)

在四种传输过程中可以分为两种操作：

- 编码：数字/模拟→数字。
- 调制：数字/模拟→模拟。

**编码(转数字)**

三种编码:

- 不归零（Non-Return to Zero）:1,0分别用两种电平来表示（常用－5V表示1，＋5V表示0）,即在连续的 1 或 0 序列中，信号电平不会发生变化
  
    > 缺点: 不具备自同步机制，必须使用外同步
    > 
- 曼彻斯特编码（Manchester Code）：使用电压的变化来表示0和1，规定在每个码元的中间发生跳变。**高到低的跳变视作0，低到高的跳变视作1**
- 差分曼彻斯特编码(Differential Manchester Code)：与曼彻斯特编码相同，在每个码元的中间，信号都会发生跳变。不同之处在于用在码元开始处有无跳变来表示0和1，**码元开始处有跳变为0，无跳变为1(两个时间片中间变没变)**。 DMC 的关键特点是使用了差分编码，即每个位的编码取决于前一个位的值。这样做的好处是消除了对绝对电平的依赖，使得信号更加抗干扰。另外，由于每个位都有信号电平的变化，可以实现时钟同步，接收方可以根据信号的电平变化来恢复数据
  
    ![4GgWusnP6A1yxRm.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281643089.png)
    

**调制(转模拟)**

数字信号的调制编码也有三种：

- 调幅（Amplitude Shift Keying, ASK）：用载波的两个不同振幅表示0和1。
- 调频（Frequency Shift Keying, FSK）：用载波的两个不同频率表示0（1.2KHz）和1（2.4KHz）。
- 调相（Phase Shift Keying, PSK）：用载波的起始相位的变化表示0 (同相）和1（反相）。
  
    ![XQo9C4KUJlEgRPW.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281643405.png)
    

**多路复用**

- 频分复用（FDM，Frequency Division Multiplexing）：将整个传输频带被划分为若干个频率通道，每个用户占用一个频率通道。**频率通道之间留有防护频带**。适用于模拟信号的传输。
  
    ![https://s2.loli.net/2024/01/05/LxjFsfV3RN6ucJO.png](https://s2.loli.net/2024/01/05/LxjFsfV3RN6ucJO.png)
    
    比如说，可以排列多个频段，每个频段4K（包含3.4K数据和0.6K间隔）
    
- 波分复用（WDM，Wave Division Multiplexing）：将整个波长频带被划分为若干个波长范围，每个用户占用一个波长范围来进行传输。适用于光纤传输。
  
    ![https://s2.loli.net/2024/01/05/HMLv3SwRNhWxKy9.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281643773.png)
    
    本质上 WDM 当然也是 FDM 的一种，因为波长不同的光，频率也是不同的。所以，WDM 可以看成一种很高频的 FDM。
    
- 时分复用（TDM，Time Division Multiplexing）：把时间分割成小的时间片，每个时间片分为若干个通道（时隙），每个用户占用一个通道传输数据。 适用于数字信号传输。
  
    ![https://s2.loli.net/2024/01/05/8RgVCO5WzsZwPA1.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281643938.png)
    

### PSTN

PSTN ，Public Switched Telephone Network 是一种常用的旧式电话系统，提供的是一个**模拟的专用通道**，通道之间经由若干电环交换机连接而成，当两台主机或路由器需通过PSTN 连接时，必须在网络接入侧使用调制解调器实现信号的模数/数模转换

**本地回路**

本地回路关注如何**使用模拟信号尽可能快速的传递数据**。主要设备是调制解调器（Modem）,根据发展历史，modem 可以分为使用4K带宽的**电话调制解调器**和使用1.1M带宽的**宽带调制解调器**（ADSL调制解调器）。

- 电话调制解调器使用电话的4K带宽，所以电话和数据传输不能                                                                                                                                                                                                                                                                      同时进行。
- 非对称数字用户线（ADSL，Asymmetric DSL）调制解调器使用本地回路的全部1.1M带宽，电话和数据传输能够同时进行，不过ADSL的上**行和下行带宽不对称**（**下行速率大于上行速率**）。ADSL采用FDM 把普通的电话线分成电话、上行和下行三个相对独立信道，从而避免相互之间的干扰。
- 光纤到户将本地回路升级为光纤，使用光信号传递数据。每大约100个用户的光纤通过分离器/组合器复合到一根到端局的光纤上，用户之间通过时分多路复用使用到端局的光纤。

ADSL分为256条信道，0 信道用于简单老式电话服务，1-5 不用防止语音信号与数据信号相互干扰，剩余的 250 个信道中两条分别用于上行流和下行流控制，剩余全部是用户数据。一般将 80% ~ 90% 的带宽分配给下行信道（也就是通常有8Mbps下载，就会有1Mbps上传）

**干线与复用**

电话呼叫多路复用技术包括:

- FDM（频分多路复用）
- WDM（波分多路复用）
- TDM（时分多路复用）

**交换**

交换局内主要设备是交换机（交换节点），交换机连接多条线路，主要功能是把一条入境线路上来的呼叫交换到一条出境线路上，从而支持呼叫一直到接收方

- **虚）电路交换**：一种面向连接的工作方式，交换设备在通信双方**找出一条实际的物理线路**的过程。分为三步：使用前建立一条从发送方到接收方的路径；使用这条路径传输；传输完毕释放路径.
其特点是建立连接的时间长、一旦建立连接就独占线路，线路利用率低、无纠错机制、建立连接后，传输延迟小
- **包/分组交换**：一种非连接的工作方式。数据被分为多个包（分组），每个包包含完整的目的地址。每个包经过交换节点时，交换节点按照当前网络状况（交换表）为其选择一条输出线路。此过程一直持续直到包被传送到目的地.
  
    ![hwS21CYRGZyrktM.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281643305.png)
    

# 数据链路层

为物理层提供高效可靠的保障服务,将一条不可靠的物理线路（line）通过协议提升为一条可靠的数据链路（data link）。有三个值得注意的关键词：

- **相邻**：两台机器之间通过一条信道连接起来，**按序到达**是其固有特性。
- **可靠**：接收方接收到的数据和发送方发送的数据一致。
- **高效**：充分利用信道的带宽（传输能力）。

## 1.成帧（位填充，字节填充）

数据链路层从网络层获取数据包，将其封装为“**帧头+有效载荷+帧尾**”的帧（Frame），数据链路层的核心就是帧的管理。

**帧**：数据链路层对等体之间交换的协议数据单元。关于帧，有这些需要知道的内容：

- 由发送方实体将**从网络层接收到的分组添加额外的字段（协议字段）封装**而成。
- 接收方实体根据协议字段的**取值执行相应的操作（协议算法）**。
- 判定接收的数据正确后，最终**将协议字段去掉，将分组提交给自己所在设备的网络层**。
- 帧的长度是有限制的。每个传输线路都有一定的差错率，帧的最大长度限制是**为了让一个帧在传输过程中出现差错这个现象成为“小概率事件”**，从而易于处理出错的帧。在网络中经常使用重传处理差错。
  
    ![hACntD87KBdb2wz.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281643070.png)
    

数据链路层，可以提供三种可能的服务（就是第一章中提到的有/无连接、可靠/不可靠服务）：

1. 无确认的无连接服务。
2. 有确认的无连接服务。
3. 有确认的有连接服务。

成帧的主要工作是将每一段来自上层的数据封装起来，使得数据链路层的接收方实体能够**正确识别一个帧的开始和结束（能够确定帧的边界）**，并能依据帧中携带的各种**控制字段（额外添加的协议字段）判断所接收帧的正确性（是否在传输过程中出错、是否是想要的那一帧）**。

确定帧的边界有一些基本的要求：容易识别一个帧的开始和结束（出错时容易同步）；开销尽可能少.

成帧有四种主要的方法：

1. **字节计数法**：利用头部中的一个字段来标识该帧中的字符数。当目的节点的数据链路层收到字节计数值时就知道后面跟随的字节数，从而可以确定帧结束的位置。
   
    > 问题：如果计数字段出错，即失去了帧边界划分的依据，接收方就无法判断所传输帧的结束位和下一帧的开始位，收发双方将失去同步，从而造成灾难性的后果。
    > 
2. **字节填充的标志字节法**：使用一些**特定的字符**来界定一帧的开始与结束。发送方的数据链路层在数据中“偶尔”出现的每个标识字节的前面插入一个特殊的**转义字节（ESC）**。接收方的数据链路层在将数据传递给网络层之前必须删除转移字节，这种技术成为字节填充。
3. **比特填充的标志比特法**：使用一个**特定的比特模式**，即`01111110`来标志一帧的开始和结束。为了不使信息位中出现比特流`01111110`被误判为帧的首尾标志，发送方的数据链路层在信息位中遇到5个连续的`1`时，将自动在其后插入一个`0`；而接收方做该过程的逆操作，即收到5个连续的`1`时，则自动删除后面紧跟的`0`，以恢复原信息。
   
    > 问题：采用2、3两种方法时，一帧的长度要取决于它所携带的数据内容。
    > 
4. **物理层编码违例法（曼彻斯特编码）**：使用“不会出现在常规数据中”的余比特作边界。好处是除了开始和结束的填充外， 不再需要填充额外的数据。
   
    令 Bit “1” 表示高-低电平对，Bit “0” 表示低-高电平对，帧的边界（高-高，低-低），这样就行了
    

## 2.差错控制（检错和纠错，CRC）

**校验和**：通信双方为了对传输的数据进行**检错和纠错**而根据一定的规则添加的**额外的位**（组合）。

例如，单个奇偶校验位（Single Bit Parity），不论是奇校验还是偶校验，EDC（即 Error Detecting Code）长度为 1 bit。

> 校验和是可以用来进行纠错的。但不保证完全
> 

重传是检测到差错之后重要的纠错方式。重传的相关概念：

- **重传**：当某一帧在传输过程中出现错误时，网络中常用的处理方法是发送方重传这一帧，而不是接收方使用纠错算法纠正错误。
  
    > 重传对发送方有资源要求，即保存自己所发送过的帧，需要时重新发送一次。只有当一帧被接收方正确接收并将帧中分组提交给网络层后，才认为这一帧的传递任务结束，才能清空保存这一帧的缓冲区。
    > 
- **确认**：接收方对自己所接收正确的帧回复一个确认，使得接收方也能知道这一帧已经被正确传输。
  
    > 有了确认机制后，发送方如果收到一帧的确认，则认为这一帧已经被正确传递，并且接收方也这样认为（否则不会发回确认），那么这一帧的传递结束，清空这一帧所使用的资源；如果发送方没有收到一帧的确认，则需要重传这一帧。
    > 
- **重传定时器**：为了避免发送方长时间地等待确认，根据线路延迟等要素估计一个确认能够返回的时间，设置为重传定时器。当等待时间超过这个时间时，则认为确认无法回来，重发这一帧。
  
    > 在定时器超时时一帧的确认没有回来，发送方只能认为接收方没有发回确认，也只能推断接收方没有收到正确的这一帧。所以选择重传这一帧。
    > 
- **编号**：为每个传递的帧确定一个编号，从而区别不同的帧。
  
    > 当接收方收到一个已经接收过的编号的帧时，则认为是重复帧，直接丢弃这一帧，但要回复一个这一帧的确认（因为接收方在等待这一帧的确认）。
    > 

### CRC循环冗余校验

循环冗余检测（Cyclic Redundancy Check，CRC）的思路是：利用冗余位`R`，使得`D+R`凑成生成多项式的倍数，这样接收方就可以通过`D+R`除以生成多项式，如果余数为0，则说明没有出错，否则说明出错。

例如：

消息`D`为`1 1 0 1 0 1 1 1 1 1`

生成多项式为`G`为`1 0 0 1 1`

1. 在`D`后面添加`G`的**长度减一（`4`）个`0`**，得到`D'`。
   
    `D'`为`1 1 0 1 0 1 1 1 1 1 0 0 0 0`
    
2. 用`D'`除以`G`，得到余数`R`。
   
    做法是跑个大除法。其中我们平时除的时候用的作差换成异或。最终，得到`R`为`0 0 1 0`
    
3. 将`R`添加到`D`后面，得到`D+R`。
   
    `D+R`为`1 1 0 1 0 1 1 1 1 1 0 0 1 0`，这就是发送的消息。
    
    ![CRC_Example_1.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281644422.png)
    
    在接收端，接收到`D+R`后，用`D+R`除以`G`，如果余数不为0，说明出错。
    
    对于CRC来说，如果检测到错误，那么证明一定出了错；但是如果没有检测到错误，不能证明一定没有出错。不过，只要经过严格的挑选，并使用位数足够多的除数G(x)*G*(*x*)，那么出现检测不到的差错的概率就很小很小。
    
    同时，CRC并不能确定究竟是哪一个或哪几个比特出现了差错。一般来说，一旦检测出差错，就丢弃这个出现差错的帧。这就需要重传机制。
    

## 3.基本数据链路协议（停等协议）

流量控制用于防止快速的发送淹没低速的接受者。**流量控制是可靠性传输的必要条件；不可靠的传输有时也需要流量控制**。

常见的流量控制机制有两种：

- **基于反馈**的流量控制（隐式，非明确指明）。
- **基于速率**的流量控制（显示，明确指明）。
  
    > 基于速率的流量控制通过显式限制发送方的发送速率实现。
    > 

流量控制技术中保证高效性的三个方式：

- **流水发送**：为了避免一帧传递完后再传递下一帧带来的线路带宽的浪费，尤其是在线路较长时， 发送方可以流水发送多帧。这需要发送方有多个缓冲区来缓存已经发送还没有收到确认的帧（没有传输完成的帧）。
- **捎带确认**：为了避免单独的确认帧浪费资源，将确认使用接收方发送的数据帧携带。这要求双工通信。
- **批量确认**：在流水场景中，接收方收到多个帧时返回一个确认，从而减少确认帧的个数。尽最大可能不触发己正确接收帧的重传。

### 停等协议

基本的数据链路层协议（也就是**停等协议**）有三种：

1. 无约束单工:工作在理想情况
   
    > 工作环境非常理想，几个前提：
    - 单工传输
    - 发送方无休止工作(要发送的信息无限多)
    - 接收方无休止工作(缓冲区无限大)
    - 通信线路（信道）不损坏或丢失信息帧
    > 
    
    ```cpp
    void sender1(void) {
    frame s;
    packet buffer;
    
    // 核心代码
        while (true) {
            from_network_layer(&buffer);    // 从网络层接收数据
            s.info = buffer;    // 将数据放入帧中
            to_physical_layer(&s);  // 将帧发送到物理层
        }
    }
    
    void receiver1(void) {
        frame r;
        event_type event;
    
        while (true) {
            wait_for_event(&event); // 等待事件
            from_physical_layer(&r);    // 从物理层接收数据
            to_network_layer(&r.info);  // 将数据发送到网络层
        }
    }
    ```
    
2. （无错信道上的）单工停等协议：增加接收方**不能无休止接收**的约束，解决方案是接收方每收到一个帧后，给发送方回送一个响应.
   
    ```cpp
    void sender2(void) {
    frame s;
    packet buffer;
    event_type event;  // 对于sender来说，这个事件只能是来了ACK
    
    // 核心代码
        while (true) {
            from_network_layer(&buffer);    // 从网络层接收数据
            s.info = buffer;    // 将数据放入帧中
            to_physical_layer(&s);  // 将帧发送到物理层
            wait_for_event(&event); // 等待事件，所谓“停-等”
        }
    }
    
    void receiver2(void) {
        frame r, s;
        event_type event;
    
        while (true) {
            wait_for_event(&event); // 等待事件
            from_physical_layer(&r);    // 从物理层接收数据
            to_network_layer(&r.info);  // 将数据发送到网络层
            to_physical_layer(&s);  // 将dummy帧发送到物理层，用来告诉sender可以发送下一个帧了
        }
    }
    ```
    
3. 有噪声/有错信道的单工停等协议：增加信道（线路）有差错，**信息帧可能损坏或丢失**的约束，解决方案是出错重传
    - 什么时候重传 --> 定时。
    - 响应帧损坏怎么办（重复帧） --> 发送帧头中放入序号。
    - 为了使帧头精简，序号取多少位 --> 1位(只在停等协议中是1位)
    
    首先规定三种情况:
    
    ```cpp
    #define MAX_SEQ 1
    typedef enum {
    	frame_arrival,
    	cksum_err,
    	time_out
    } event_type;
    ```
    
    于是有sender：
    
    ```c
    void sender3(void) {
        seq_nr next_frame_to_send;  // 正在发送的帧的序号
        frame s;
        packet buffer;
        event_type event;
    
        next_frame_to_send = 0;       // 初始化
        from_network_layer(&buffer);  // 从网络层获取初始数据
    
        while (true) {
            s.info = buffer;
            s.seq = next_frame_to_send;
            to_physical_layer(&s);
            start_timer(s.seq); // 启动定时器
            wait_for_event(&event);
            if (event == frame_arrival) {
                from_physical_layer(&s);    // 拿ACK
                if (s.ack == next_frame_to_send) {  // 收到对应的ACK
                    stop_timer(s.ack);
                    from_network_layer(&buffer);    // 这个“停-等”已经顺利完成，可以从网络层拿下一个数据了
                    inc(next_frame_to_send);    // 自增帧序号
                }
            }
        }
    }
    ```
    
    对于receiver：
    
    ```c
    void receiver3(void) {
        seq_nr frame_expected;
        frame r, s;
        event_type event;
    
        frame_expected = 0;
        while (true) {
            wait_for_event(&event);
            if (event == frame_arrival) {
                from_physical_layer(&r);    // 拿到帧
                if (r.seq == frame_expected) {  // 就是你了！
                    to_network_layer(&r.info);
                    inc(frame_expected);
                }
                s.ack = 1 - frame_expected; // 这样可以说明ACK了哪个帧
                to_physical_layer(&s);
            }
        }
    }
    ```
    
    这个协议能够实现重传，是因为：
    
    - 如果拿到正确帧，相安无事
    - 如果拿到校验和错误，啥也干不了，等超时
    - 如果拿到超时（或者说上一种情况的超时），最终会自动超时重传

## 4.滑动窗口协议（捎带确认，发送/接收窗口，一位滑动窗口，回退N，选择性重发协议）

**捎带确认（piggybacking）**：暂时延缓确认以便将确认信息搭载在下一个出境数据帧上的技术

滑动窗口协议总共有三种，他们都能在实际（非理想）环境下正常工作，区别仅在于效率、复杂性和对缓冲区的要求，他们分别为：

- 1-bit 滑动窗口协议（发送窗口大小=1，接收窗口大小=1）
- Go Back N 协议（发送窗口大小>1，接收窗口大小=1）
- 选择重传协议（发送窗口大小>1，接收窗口大小>1）

### 1-bit

看起来和停-等很像，唯一区别在于发的帧捎带了ACK，和停-等相比，少一步单独ACK，所以效率更高。

现在我们考虑出错的情况，如果checksum出错，等超时重发就好了。如果我收到了一个ACK，但是ACK的序号不对，等超时重发就好了。总之就是，不是我要的就全让他们timeout就行了。我只在正确响应ACK时才停掉计时器

```cpp
void protocol4(void) {
    // 此乃双工协议，一个函数，同时收发
    seq_nr next_frame_to_send;  // 下一个发送的帧
    seq_nr frame_expected;      // 下一个期望收到的帧，这俩在这个协议中都是要么0要么1
    frame r, s;
    packet buffer;
    event_type event;

    next_frame_to_send = 0;
    frame_expected = 0; // 这俩都是初始化
    
    from_network_layer(&buffer);    // 从网络层取数据
    s.info = buffer;    // 准备发第一帧
    s.seq = next_frame_to_send; // 发送的帧号
    s.ack = 1 - frame_expected; // 捎带ACK
    to_physical_layer(&s);  // 发送第一帧
    start_timer(s.seq); // 开始计时
    
    while (true) {
        wait_for_event(&event);
        if (event == frame_arrival) {
            from_physical_layer(&r);

            if (r.seq == frame_expected) {//作为接收方
                to_network_layer(&r.info);//接收
                inc(frame_expected);    // 期望收到的帧号自增（虽然实际上是反转但是反正意思到了）
            }
            
            if (r.ack == next_frame_to_send) {//作为发送方
                stop_timer(r.ack);  // 停止计时
                from_network_layer(&buffer);
                inc(next_frame_to_send);
            }
            
            s.info = buffer;
            s.seq = next_frame_to_send;
            s.ack = 1 - frame_expected;
            to_physical_layer(&s);
            start_timer(s.seq);
        }
    }
}
```

### Go Back N和选择性重传

![Go_Back_N_Example.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281644013.png)

上图中上半部分是后退N,下半部分是选择性重传.

- 后退N代表如果某个帧传输错误,那么从这一帧到超时过程中所有的帧都需要重传,因为接收窗口大小为1,这期间所有的帧都无法被接收.
- 为了弥补这个明显的缺陷,选择性重传的接收窗口大于1,因此失败帧到超时过程的其他帧(图中就是345)可以被缓存,于是只用重传2,并且**累积确认**到最大序列号5

# 介质访问子层

Medium Access Control，MAC 子层还是**属于数据链路层**，是它的一个子层，实际上是**整个数据链路层的底层**。

在同一介质中相同频率波段的传输信号会相互干扰，导致无法得到有效的信号，而采用频率，时间区别不同信号又无法最大限度地利用资源，这时候就希望有种协议**可以协商三个以上的机器如何可以在没有统一调度的前提下“遵守秩序”、“不打断别人”地发言，让介质顺利被利用不产生冲突**。

所以说，根本上讲，介质访问控制（MAC）是**当多个使用者共享同一个信道时，确定下一个使用者的问题**

## 1.信道分配（静态＆动态）

**多路复用**：多个信号组合起来在一条物理信道上进行传输的方式。多路复用可以提高对带宽的利用率，其方法主要有三种：

1. 频分多路复用（FDM）
2. 时分多路复用（TDM）
3. 波分多路复用（WDM）

静态 FDM 性能差，因为它会 N 倍放大延迟，即：$T_{FDM}=NT$。其中 T 是 FDM 之前原本的平均延迟。显然，这一切对于 TDM 也是一样的.

介质访问控制问题的基本解决思路可以分为两种：**基于冲突的和无冲突的解决方案**，还有一种混杂协议结合这两种方案特点的**有限竞争协议.**

- **无冲突的解决方案**各站点遵守事先确定的竞争规则，合理安排各个站发送数据的顺序，不会产生冲突。包括以下几个协议：
    - 基本位图法：在一个竞争周期内，如果某个站有数据发送，则当其对应的时槽到来时置1，错过则等待下一个竞争周期。竞争周期结束后，时槽置1的站轮流发送数据。需要**事先安排各个站的编号及对应的竞争时槽**。
    - 令牌传递：所有站组成一个逻辑环，令牌按照某种方向在逻辑环上传递。获得令牌的站拥有发送数据的权力。发送完毕后，将令牌向后传递到下一个站。需要**事先安排逻辑环上各个站的顺序**。
    - 二进制倒计数：每个站拥有一个逻辑地址，发送时各个站按位从高到低广播自己的逻辑地址。信道将所有地址位布尔或在一起。每个站将自己的地址位与布尔或后的位比较，自己地址位小的竞争失败并放弃发送后续的地址位。最终剩余的站竞争成功并随后发送数据。需要**事先安排站的逻辑地址**。
- **基于冲突的解决方案**没有事先约定的竞争顺序，各个站公平地竞争信道。此时，冲突不可避免，协议基于冲突解决各个站的发送顺序。
- **有限竞争协议**综合以上两种协议特点，将所有站分成若干个组，组内公平竞争（基于冲突），组间按照一定顺序竞争（无冲突）。
- **无线局域网**拥有不同于有线局域网的特点，冲突检测困难，信道侦听复杂，采用了**类似于经典以太网但冲突避免**的协议。

因此，基于冲突的协议和无线局域网都需要处理竞争问题，基于竞争解决MAC问题的几个关键思想如下：

- 时间离散化。
- 随机发送。
- 载波侦听（不打扰已有通信）。
- 失败重传（基于冲突检测或确认是否回来）。

这部分的实践是基本一致的，无论是经典以太网还是无线局域网。这样的网络里都可能有多个站点有数据发送，此时：每个站点**随机选择发送时间以尽最大可能避免冲突**，使得某个站点在所选时刻以较大概率独自发送（竞争成功）；其它站点能够**感知这个发送不再干扰**（通过载波侦听）；**冲突后重传**。

但是：

- 经典以太网比较容易检测冲突，所以采用较为激进的1-坚持CSMA，冲突后使用**2进制指数后退算法**分解冲突。
- 无线局域网难于检测冲突，直接采用冲突避免的改进的**p-坚持CSMA**分解冲突。
- 交换式局域网采用缓存与合适的调度算法分解冲突。

## 2.多路访问控制协议（ALOHA，CSMA，CSMA/CD，最小帧长，MACAW）

经典以太网每个时刻只允许一个站点发送数据。没有事先规定的竞争顺序，允许竞争时产生冲突，并基于冲突解决介质访问控制问题。

### 先说后听(想说就说)ALOHA

按照对时间管理的不同，分为连续时间和离散时间，对应的协议分别为：纯ALOHA，分槽ALOHA

- **纯ALOHA协议**：当站点有数据要发送时就发送。如果多个用户同时发送则会发生冲突造成发送失败。发送失败后（发送站会依靠某种方法得知），等待一段随机时间再次发送。**等待一段随机时间为了有效解决冲突**。
- **分槽ALOHA协议**：是纯ALOHA协议的改进。将时间离散化，分为时间槽（一段事先规定的时间）。只有在时间槽的起始点可以发送。通过推迟发送时间，**避免连续时间发送带来的某些冲突**。
  
    ![kwUOCsm7vhofEDX.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281644199.png)
    

纯ALOHA的系统吞吐量$S=G⋅e^{-2G}$，其中G是系统负载，也就是平均下来每帧时内产生的帧数；S是每帧时内成功传输的帧数。显然，首先就有S≤1

Slotted ALOHA 就不一样了，吞吐量$S=G⋅e^{−G}$。分槽使得碰撞危险减少了一半。

> pure的危险时间是发送时刻往前一个帧时和往后一个都不能有发送,slotted由于只能在时间槽开始发送,因此危险时间少发送时刻往后一帧时
> 

### 先听后说CSMA

这种发送数据之前先侦听信道是否空闲的协议称为**载波侦听多路访问协议（CSMA，Carrier Sense Multiple Access）**。根据贪婪程度和处理策略不同，分为：

- 坚持CSMA：站点在发送数据之前首先侦听信道。如果信道空闲，则发送；如果信道忙，则**继续侦听，直到信道空闲，立即发送**。避免打扰已有的通信，但是**不能完全避免冲突**。
  
    > 可能的冲突情况：假如现在站点A正在发送数据，站点B想要发送数据，先侦听信道，信道忙，则站点B持续侦听信道。接着（或“同时”）站点C也有数据要发送，执行同样的协议。当站点A发送完毕后，站点B和C都侦听到信道空闲，都会选择立即发送。结果，站点B和C发送数据冲突，都会发送失败。
    > 
    
    1-坚持CSMA只是**将连续时间上的冲突压缩到前一个数据传递完毕（一个时刻）**。
    
- 非坚持CSMA：站点在发送数据之前首先侦听信道。如果信道空闲，则发送；如果信道忙，则**等待一段随机时间再来侦听**。能够有效避免1-坚持CSMA协议不能真正分解冲突的问题。
- p-坚持CSMA：适用于**时间分槽系统**。站点在发送数据之前首先侦听信道。如果信道空闲，则以概率p发送数据；以概率1−p推迟到下一个时槽；重复以上过程，直到发送出去或听到信道忙。如果信道忙，则等待一段随机时间再来重复以上协议。
  
    ![The_Comparison_Between_Multiplexing_Algorithms.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281644722.png)
    

### 边说边听CSMA/CD

站点**边发送边监听，并在监听到冲突之后立即停止发送，并立即进入竞争周期，尽快得到竞争解决方案**

实现机制：

- 发送方一边向信道发送（说）数据，一边从信道上读取（听）数据，通过**判断双方是否一致来判断是否发生了冲突**。
- 所有站点还要同时运行**冲突检测（CD, Collision Detection）协议**，边发送数据（竞争信号）边检测信道上是否发生了冲突。如果听到冲突，则表明还有其它站点“同时”发送数据，代表本次发送失败（所有发送站点都会意识到这一点）。听到冲突的站点立即停止发送（提高效率），运行**BEB协议**分解冲突。
- 如果站点在发送过程中没有听到冲突，则认为本次发送成功（或取得总线的控制权）。

### 最小帧长

**最小帧**：为了确保发送站在发送数据的同时能够检测到可能存在的冲突，需要在发送完帧之前就收到自己发送出去的数据。

**最小帧长**：发送方必须发送的最小时间，对应着必须发送的最少数据。凡是小于最小帧长的帧就把它当做无效帧丢弃。

一个站点执行 CSMA/CD 协议，当发送（竞争）过程中没有听到冲突，则认为发送（竞争）成功。然而，考虑到信道传输延迟时，这个结论需要前提条件保证才是正确的，那就是：**发送方必须发送足够长时间的数据**，才能够检测到发生在“远方”的冲突，从而做出正确的判断.

$最小帧长 = 总线传输时延×数据传输速率×2 = 2τ×以太网的速度$

![The_Math_Behind_The_Minimal_Frame_Length.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281644656.png)

其实就是说，最先发送数据帧的站，在发送数据帧后至多经过时间2τ2*τ*（两倍的端到端往返时延），就可知道发送的数据帧是否遭受了碰撞。故，将2τ2*τ*称为争用期或碰撞窗口。经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。

例题：假设一个采用 CSMA/CD 的 100 Mbps 局域网，最小帧长是 128B，则在一个冲突域中两个站点间的单程传输延时最多是？

- [ ]  A. 2.56*μs*
  
    μs
    
- [x]  B. 5.12*μs*
  
    μs
    
- [ ]  C. 10.24*μs*
  
    μs
    
- [ ]  D. 20.48*μs*
  
    μs
    

解：$128B=2τ×V$，而V=100Mbps，解得*τ*=2.56*μs*。当然，两个站点间的单程传输延时最多是2τ，也就是5.12μs

## 3.以太网（二进制指数后退算法，最小帧长，曼彻斯特编码，差分曼彻斯特编码，802.3帧格式）

### BEB算法（Binary Exponential Backoff Algorithm）

方案描述如下：

1. 站点运行CSMA/CD协议，听到冲突后进入**竞争周期**，时间离散为多个时间槽。
2. 如果第一次冲突，则参与竞争的站点在**随后的两个时间槽内随机选择一个发送**，发送前依然要侦听信道是否空闲。
3. 排在**最前面的只有一个竞争者的时间槽**对应的竞争者竞争成功，随后抓住信道发送数据，其它竞争者等到选择的竞争时间槽时侦听信道为忙，只能等待已有通信完成再次尝试发送。
4. 当一个时间槽有两个竞争者就都会听到冲突，全部竞争失败。**竞争失败的站点将随机等待的时间槽数加倍，然后从中随机选择一个参与竞争**，直到竞争成功或达到最大竞争次数。
5. 二进制指数后退指的是每次冲突后随即后退的时间槽翻倍，直到1024个时间槽（即10次冲突）。如果在1024个时间槽运行6次（也就是总计16次尝试）依然解决不了冲突，则认为网络坏了。
6. **竞争周期时间槽的时间应该远远小于普通帧长**。这样能够减少冲突带来的消耗，提高信道使用效率。
7. 对每一个站点，选择任何一个时间槽都是公平的。因为**一个时间槽的好坏不只是取决于是否靠前，更重要的是是否其它竞争者也选择了这个时间槽（博弈论）**。
8. 竞争周期的最后结果是某一个站点获得信道使用权
   
    ![rnht5eBgZTM7Wdq.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645738.png)
    

### 交换以太网

交换以太网是以交换机为核心设备而建立起来的一种高速网络，可在高速与低速网络间转换，实现不同网络的协同。**交换机分割了连接的不同网络成为不同的冲突域，不同冲突域之间信号不会彼此干扰，所以不用考虑不同自治域间的冲突问题**

使用的网络设备为**网桥或交换机**。网桥（交换机）的功能是将连接的网段断开，需要时连接（桥、桥接）。这样，发生在一个网段的通信信号不会“自动”（像中继器、集线器那样）转发到另外的网段。网桥/交换机使用缓存和调度避免冲突、实现转发桥接功能。

![WKuslw4QyofiEng.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645445.png)

### 帧格式

![The_Structure_of_Ethernet_Frame.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645064.png)

图上半是DIX以太网,下半时IEEE 802.3格式,可以看出主要的不同在于802.3多一个SOF(start of frame)帧开始表示,以及没有type有length

| **Structure** | **结构** | **长度** |
| --- | --- | --- |
| DA, Destination Address | 目标地址 | 6B |
| SA, Source Address | 目标地址 | 6B |
| Type | 类型 | 2B |
| Data | 数据（其实就是IP数据报） | 0~1500B |
| Pad | 间隔/填充（用来保证合法地满足最小帧长） | 0~46B |
| Checksum | 校验码 | 4B |

有的时候把Data和Pad合计为Data字段，长度至少为46B；另外，值得注意的是，DA与SA都是6B，这实际上也印证了MAC地址的长度。

MAC帧无效的情况：

- 数据字段的长度与长度字段的值不一致
- 帧的长度不是整数个字节
- 用收到的帧检验序列 FCS 查出有差错
- 数据字段的长度不在 46 ~ 1500 字节之间

对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧

## 4.WLAN（隐藏站和暴露站问题，CSMA/CA，802.11 MAC子层协议）

无线局域网只使用一个信道，支持广播传输模，形式上类似于经典以太网。

无线局域网与有线局域网的不同：

1. 两者的传输介质有着本质区别，也正是这种区别，导致WLAN存在新的问题：隐藏终端问题和暴露终端问题。
2. 两者传输范围有区别：WLAN 中，无线电传输范围有限，一个站不能给所有其他站发送帧，也无法接收来自所有其他站的帧；在有线局域网中一个站发出一帧，所有其他站都能接收到。
3. 信道检测方式不同：WLAN采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式；以太网通过电缆中电压的变化来检测。
4. 在 WLAN 中，对某个节点来说，其刚刚发出的信号强度要远高于来自其他节点的信号强度，也就是说它自己的信号会把其他的信号给覆盖掉，但在本节点处有冲突并不意味着在接收节点处就有冲突。

### 隐藏/暴露站问题&MACA（Multiple Access with Collision Avoidance protocol）

MACA（Multiple Access with Collision Avoidance protocol）的工作方式基本是:

1. 发送方刺激一下接收方（RTS帧），让他输出一个短帧（CTS帧），因此接收方附近的站可以检测到该帧，从而在接下去的数据帧（较大）传输过程中他们不再发送数据了。
2. 发送方发送RTS（request to send）帧，这个短帧包含了随后要发送的数据帧的长度，接收方用CTS（Clear to send）作为应答，此CTS也包含了数据长度。
3. A在接收到了CTS后开始传输。

在WLAN中，存在隐藏终端和暴露终端两个基本的问题：

**隐藏终端问题**：无法感知彼此的发送者，但仍会在预定的接收方发生碰撞。如下图所示：

![KUoGHdyZigWnTC9.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645322.png)

例如，A 给 B 发，但 C 的信号接收覆盖范围没法覆盖到 A，导致不知道A在给B发，误以为B 空闲，一旦发送，则信号会冲突干扰，导致失效.

**暴露终端问题**：可以相互感知但仍然安全地传输（到不同的接受者）的发送者

例如，B给A发，此时 C 想要发送信号给D，但C监听到介质上有信号传输，则会等待B 传输结束再进行给 D 的传输，但实际上这种等待是不必要的

### 802.11MAC子层协议

802.11在MAC子层的协议上有两种：

1. DCF（Distributed Coordination Function）:在 DCF 中，节点通过监听信道来检测是否有其他节点正在发送数据。如果信道空闲，节点可以开始发送数据。如果信道被占用，节点将等待一段随机的时间（退避时间），然后再次尝试发送。这种退避机制有助于避免碰撞，并提供了一种分布式的协调方式。
2. PCF（Point Coordination Function）:在 PCF 中，主节点负责调度节点的访问。它周期性地发送一个帧，称为 Beacon 帧，来通知其他节点网络的存在和 PCF 的可用性。主节点根据一定的调度算法，分配时间片给各个节点，使它们可以按照指定的时间间隔发送数据。

**CSMA/CA（CSMA with Collision Avoidance）是带有冲突避免的CSMA协议。**与之前的 MACA 相比，它**引入了短确认确保每一帧的发送成功**，即数据发送后站点启动确认计时器，如果计时器时间到但没有收到接收方回复的收到的确认，则试图重新发送。但它在RTS 和 CTS 方面并**没有考虑暴露终端问题**。

CSMA/CA有两种工作模式：

- 模式一：感测信道，如果空闲，则开始传输。如果发生冲突，则等待随机时间，使用以太网二进制指数退避算法；
- 模式二：基于MACAW，使用虚拟信道感知。例如，A 想要给 B 发送数据，C 在 A 的发送范围内，而 D 在 B 的发送范围内，但不在 A 的发送范围内。A 发送 RTS 给 B，B 发送 CTS；A 开始发送数据，并且启动 ACK 计时器。此时，C 会收到 RTS，D 会收到 CTS，这就用上了 NAV（Network Allocation Vector）。

**RTS与CTS**：与MACA 类似，但是将规则改成了听到 RTS 后也停止传输一切东西，直到此次数据传输结束后再进行传输。这样其实是无法解决暴露终端问题的，但由于考虑到暴露终端问题是效率问题而不是致命问题，且处理这个不经常发生的问题需要耗费操作时间，所以就进行了舍弃。

**网络分配向量（NAV，Network Allocation Vector）**：每格站点保留的信道何时要用的逻辑记录，**每个帧携带一个 NAV 字段，说明这个帧所属的一系列数据将传输多长时间**。所有听到数据帧的站将在发送确认期间推迟发送，不管能否真正听到确认的发送。

**二进制指数后退的CSMA/CA**：侦听很短的一段时间后发现没有信号，则随机选择 0-15 个时间槽进行倒计时倒数，当听到有帧发送时暂停倒计时，空闲时计数，到0时就发送，如果发送成功则目标站会发送一个短确认，如果没收到确认，则发送方加倍自己选择的时间槽数，重新试图发送。如此反复， 直到成功发送帧或达到最大重传次数.

## 5.数据链路层交换（网桥（散列表，洪泛算法，逆向学习，动态拓扑结构变化），生成树网桥，中继器，集线器，交换机，路由器，网关）

### 网桥/交换机

网桥的工作过程如下：

1. 当一帧到达时，网桥必须决定是将该帧转发还是丢弃
2. 如果决定转发，还必须要决定在哪个端口传输帧
3. 网桥通过在其内部配备一个大的（哈希）表来查询一帧的目的地址，该表中列出了每一个可能的目的地址以及它隶属的输出端口
4. 当网桥第一次被接入网络时，所有的哈希表都是空的，网桥使用洪泛算法完善哈希表。
5. 其具体转发过程为：
    1. 目的地址的端口与源端口相同，则丢弃该帧
    2. 目的地址的端口与源端口不同，则转发该帧到目的端口
    3. 目标地址端口未知，则使用洪泛算法，将帧发送到所有的端口，除了他入境的那个

**泛洪算法**：不需要知道网络的拓扑结构和相关的路由计算，**仅要求接收到信息的节点以广播的形式转发数据包**。对于每个发向未知目的地址的入境帧，网桥将他输送到所有的端口，除了它到来的那个端口，慢慢的网桥学习到目标地址在哪里,和向后学习法（通过检查每个窗口上发送的所有帧的源地址)，网桥就可获知通过那个窗口能访问到哪些机器.

网桥（交换机）的**交换功能**主要由三个模块组成：**转发模块**、**自学习模块**和**MAC-端口映射表（也称MAC地址表）**。

**转发模块**依据映射表决定入境的帧应该从哪个端口转出。转发规则为：

1. 当发送方和接收方在同一个端口，则不转发；
2. 否则，如果查找映射表成功，按照映射表转发；
3. 否则，向其余全部端口转发。

**自学习模块**主要负责“实时”（可能几分钟）地将网络拓扑（主要指**站点和端口的连接关系**）的情况和MAC-端口映射表同步。简单说，让**映射表能够动态反应网络拓扑的变化**。

- 自学习模块采用**后向（逆）学习机制**：当收到一个入境帧时，将其内部携带的“源地址”与进入端口的关联关系写入映射表中。
- 自学习模块是一种**动态学习机制**：映射表是动态建立的，能够动态反应网络拓扑。开始时为空，随着流量的增多，映射表不断完善。
- 映射表中每个表项关联一个**计时器**，在规定时间内没有刷新的表项会被删除。

**MAC-端口映射表**（MAC地址表）记录目的地址（物理地址）对应的端口号和更新时间。

### 生成树网桥

**生成树网桥**：最低标识符（基于MAC地址）的网桥作为生成树的根。

为了提高可靠性，有人在LAN之间设置了并行的两个或多个网桥，但是，这种配置引起了另外一些问题，因为在拓扑结构中产生了回路，可能引发无限循环。

解决上面所说的**无限循环问题的方法是让网桥相互通信，并用一棵到达每个LAN的生成树覆盖实际的拓扑结构。使用生成树，可以确保任两个LAN之间只有唯一一条路径。**一旦网桥商定好生成树，LAN间的所有传送都遵从此生成树。由于从每个源到每个目的地只有唯一的路径，故不可能再有循环。

为了建造生成树，首先必须选出一个网桥作为生成树的根。实现的方法是每个网桥广播其序列号（该序列号由厂家设置并保证全球唯一），**选序列号最小的网桥作为根。（经过足够的消息交换和扩散）接着，按根到每个网桥的最短路径来构造生成树**。结果，从每个LAN到根建立了一条唯一的路径，因而从每一个LAN到其他任何一个LAN也建立了一条唯一的路径。如果某个网桥或LAN故障，则重新计算。

### 各种网络设备

- 中继器：物理层，模拟设备，用于连接两根电缆段，放大信号。
- 集线器：物理层，有许多输入线路，它将这些输入线路连接起来，在任何一条线路上到达的帧都被发送到其他线路上。
- 交换机：数据链路层，多端口的网桥。根据帧的目的地址转发，常被用来连接独立计算机。
- 路由器：网络层，当一个分组进入到一个路由器中的时候，帧头和帧尾被剥掉，位于帧的 IP 分组被传递给路由软件，路由软件利用分组的头信息来选择一条输出线路。
- 网关：传输层，应用层。应用网关是将一个网络与另一个网络进行相互连通，提供特定应用的网际间设备，应用网关必须能实现相应的应用协议。应用网关可设在应用层或传输层。设在应用层的叫应用层网关，也称代理服务器。设在传输层的叫传输层网关。

网桥和路由器的主要区别：

1. 网桥只能连接两个**逻辑相同的网络（它相当于一个二层交换机）**，而路由器可以连接不同网络；网桥就是把不同物理位置的机器组成一个大的局域网，连接的多个网络属于同一个局域网；网桥连接的两个网络在逻辑上属于同一个局域网，但可以是不同策略的网络，如以太网和令牌环网；路由器可以连接不同的网络，连接的网络之间可以说没什么关系，是独立的。
2. 网桥基于 MAC 地址转发，路由器基于 IP 转发。
3. 网桥不隔离广播，而路由器可以隔离广播。
4. 网桥工作在链路层，路由器工作在网络层。

# 网络层

## 1.网络层设计要点（虚电路子网，数据报子网）

网络层的功能通过网络层设备**路由器**实现。路由器是网络层设备，除了具有网络层的功能以外，还具有物理层和数据链路层的功能。

当一个IP分组到达路由器其主要的转发过程：

1. 当有一个IP分组到达路由器，进入等待队列，通过某种调度方式进行调度。
2. 调度到这个消息时，取出其目的地址，并将其与路由表中所有的网络号的子网掩码进行匹配，选取最长匹配的地址进行转发。
3. 如果没有匹配的表项，发送到缺省表项继续转发。

**存储转发**：将入境数据缓存（存储），根据一定的规则调度到出境端口并发送（转发）的过程。

网络层向传输层提供的服务**包括无连接的服务和面向连接的服务**：

- **数据报子网**：使用无连接的服务，所有的数据包都独立地注入到网络中，并且每个数据包独立路由，不需要提前建立任何设置。数据包通常成为数据报，对应的网络成为数据报网络。
- **（虚）电路子网**：使用面向连接的服务，在发送数据包之前，必须先建立起一条从源路由器到目标路由器之间的路径，这个连接成为虚电路，对应的网络成为虚电路网络。

无连接服务将所有的数据包被独立地注入到网络中，每个数据包**携带完整的目的地址**，在网络中被独立路由（被每一跳路由器根据本身的路由表确定下一步的转发线路）。数据包之间由于网络状态的变化（反映到某些路由器路由表的变化，从而导致从当前路由器以后路径的变化）可能经过不同的路径。所谓“独立”，指的是**任意两个数据包的路径没有相关性**。

面向连接的服务事先为一次传输确定一条路径（虚电路，虚的含义是使用一条线路的部分资源而非全部），**本次传输中的所有数据包使用同样的路径递交**。虚电路使用一个标识符标识本虚电路。虚电路标识符具有“局部（本地）”特征，即每台路由器可能选择不同的标识符。标识符在整条路径上不断变化，不影响数据转发。每个数据包**携带一个虚电路标识符**用于中间路由器的转发，每经过一个路由器，虚电路标识符的取值可能变化。

二者可以总结为如下表格：

| 问题 | 数据包网络 | 虚电路网络 |
| --- | --- | --- |
| 电路建立 | 不需要 | 需要 |
| 寻址 | 每个包包含全部的源和目的地址。 | 每个包包含简短的VC号。 |
| 状态信息 | 路由器不保留连接状态。 | 针对每个连接，每条VC都需要路由器保留其状态。 |
| 路由方式 | 每个数据包被单独路由。 | 建立VC时选择路由，所有包都遵循该路由。 |
| 路由器失效的影响 | 没影响，除了那些路由器崩溃期间丢失的包。 | 穿过故障路由器的所有VC都将崩溃。 |
| 服务质量 | 困难 | 容易，如果在预先建立每条VC时有足够的资源可以分配。 |
| 拥塞控制 | 困难 | 同上 |

## 2.路由算法（最优化原则，sink tree,最短路径路由，距离矢量路由，链路状态路由，分级路由，广播路由，移动路由）

路由算法和路由协议是路由器中的一个重要功能，目标是建立和维护存放在路由器中的路由表。路由器还有另外一个重要功能，即**使用路由表对数据进行的转发功能（被路由功能，如IPv4）**。

### 最优化原则

**最优化原则**：如果路由器J在从路由器I到路由器K的最优路径上，那么从J到K的的这一段子路径必定是从J到K的最优路径。

最优化原则可以**避免环路**，即遵循最优化原则计算的路径没有环路，但是当**网络拓扑收集不准确时，可能造成环路**。

路由算法就是计算寻找**以所有路由器为目标节点的汇聚树**。

> 汇聚树：从所有源节点到一个指定目标节点的最优路径的集合构成一棵**以目标节点为根的树**。汇聚树分布保存在路由节点中，每个路由节点只需保存一步路由（下一跳）。从每个路由器开始的每步综合起来，就是从本节点到指定目标节点的最优路径。
> 

动态路由/自适应路由算法：每个路由器能够**根据当前的网络状态（网络拓扑）计算从自己到所有其它路由器的最短路径**，包含两个方面的内容：获得当前的网络状态，根据网络状态计算路由。

根据获得当前网络状态和计算最短路由的不同，常见的路由算法有：

- 距离矢量路由算法
- 链路状态路由算法
- 二者的混合

### 距离矢量路由

距离矢量路由的原理是每个路由器**维护一张表**，表中列出了**当前已知的到每个目标的最佳距离，以及所使用的链路**，这些表通过邻居之间相互交换信息而不断被更新，最终每个路由器都了解到达每个目的地的最佳链路，其过程包括两个步骤：

- 每台机器周期性的将自己的距离矢量发送给自己的所有邻居。
- 每台机器根据邻居的距离矢量计算自己新的路由表.
  
    ![Example_of_DVR.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645668.png)
    
    ![903d131a231405e5ab34eb7ac447395b.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645945.png)
    
    ![83f0f074ee75a5fb6decff18512d3941.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645600.png)
    

但是距离矢量路由算法只是**根据邻居的距离矢量计算自己的路由表**，当计算一条路径时，无法判断邻居所说的最短路径是否通过自己（这是分布式算法本身固有的缺陷），所以可能带来环路问题。

环路的补救与避免：

1. 定义最大值。在RIP (Routing Information Protocol)路由协议中，允许跳数最大值为16 ，这个方案只是补救措施，不能避免环路产生。
2. 水平分割。水平分割的思想就是在路由信息传送过程中，不再把路由信息发送给接收此路由信息的接口上（原因：路由器将从某个邻居学到的路由信息又告诉了这个邻居）

### 链路状态路由

链路状态路由算法中，一个结点**检查所有直接相连**的链路状态，并将所得的状态信息**发送给网络上的其他所有结点**，而不是仅仅发送给相邻的结点。包含如下过程：

1. 发现邻居节点（HELLO）
2. 测量线路开销或延迟（ECHO）
3. 构造链路状态分组（发送标识，seq，age）
4. 发布链路状态分组（泛洪算法）
5. 计算新最短路由（Dijkstra算法）

链路状态路由算法在网络内的可靠性扩散过程：

1. 每个分组都包含一个序列号。当一个新的链路状态分组进来的时候，路由器在已经看到的分组列表中检查这个新进来的分组：
    1. 如果他是新的，那么除了它到来的那条线路之外，在其他的线路上全部转发该分组。
    2. 如果他是一个重复分组，则将他丢弃。
    3. 如果一个分组的序列号小于当前所看到过的来自该源路由器的最大序列号，则作为过时分组而拒绝。
2. 每个分组的序列号之后包含年龄信息，每秒钟将年龄减一，当年龄=0时，来自该路由器的信息被丢弃。
3. 当一个链路状态分组被扩散到一个路由器中时，他并没有立即加入到队列中等待传输，而是放到一个保留区中等待一段时间。如果在这个分组被发送出去之前，另一个来自同一个源路由器的链路状态分组到来，那么比较他们的序列号，如果相等则丢弃，不相等则把老的丢弃。
4. 所有的链路状态分组都要被确认。

与距离矢量路由算法相比：

- 链路状态路由算法需要更多的内存和计算。
- 不存在慢收敛的问题。
- 链路状态路由某个路由将自己的路由状态告诉全部路由器，而距离矢量只是将路由状态告诉给邻居路由器即可。
    1. 链路状态路由算法向本自治系统中的所有路由器发送消息，这里使用的是泛洪法（路由器通过所有端口向相邻路由器发送信息，而每一个相邻路由器又发给所有相邻路由器，但不再发给刚才发来信息的路由器）。而距离矢量路由算法是仅仅向自己相邻的几个路由器发送信息。
    2. 链路状态路由算法发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”。而在距离矢量路由算法中，发送的信息是本路由器所知道的全部信息，即整个路由表。
    3. 只有当链路状态发生状态时，链路状态路由算法路由器才用泛洪法向所有路由器发送此信息，并且更新过程收敛得快，不会出现距离矢量路由算法“坏消息传得慢”的问题。而在距离矢量路由算法中，不管网络拓扑是否发生变化，路由器之间都会定期更换路由表的信息。

### 层次路由

随着网络规模的增长，路由器的路由表也成比例增长，结果是路由器效率下降，成为网络服务的瓶颈。解决之道是将网络分层，采用分层路由之后，路由器被划分成区域，每个路由器知道如何将数据包路由到自己所在区域内的目标地址，但是对于其他区域的内部结构毫不知情。

### 广播路由

广播路由算法的目的是将一个分组从源节点传送到网络中的所有节点。广播路由算法的一个重要应用是路由器的路由表的建立。

几种算法：

- 算法1：分别发送分组到每个目的端
- 算法2：扩散法（Flooding）
- 算法3：多目的地路由选择:种算法是通过给每个目的地指定一个逻辑地址,然后路由器根据这个逻辑地址选择最近的实际目的地进行转发。
- 算法4：利用发起广播的路由器的汇集树或利用生成树
- 算法5：逆向路径转发

### 多播路由

实现方法：

- 良好的小组管理机制
    - 创建和取消小组
    - 允许进程进入、离开小组
- 发送时，第一个路由器检查生成树，修剪小组成员不能到达的线路

## 3.拥塞控制（RED）

**拥塞**：网络中存在太多数据包导致数据包被延迟和丢失，从而降低了传输性能。当拥塞出现后，有可能遭遇拥塞崩溃。

完整的流量控制应该是网络层（RED协议）和传输层（TCP慢启动）共同配合的任务。

拥塞产生的原因：

1. 传输层注入太多的、超过网络处理能力（网络容量）的数据。
2. 网络层路由协议不能充分使用网络资源、不能适应流量的分布变化。
3. 网络资源不足以支持流量。

虚电路子网中的拥塞控制主要有两个方式：

1. 准入控制
2. 资源预留

数据报子网中有三种方式：

1. 警告位
2. 抑制分组
3. 逐条抑制分组

### RED随机早期检测

**随机早期检测（RED，Random Early Detection）**：为了确定何时开始丢弃数据包，路由器需要维护一个运行队列长度的平均值。当某条链路上的平均队列长度超过某个阈值时，该链路就被认为即将拥塞，因此路由器随机丢弃一小部分数据包受到影响的发送方会发现丢包，然后传输协议将放慢速度）。

> 采用随机丢包而不用抑制包的原因：当拥塞时，若路由器向发送方发抑制包，那么大量的抑制包反而会加重拥塞。所以网络层解决拥塞的思路就是防患于未然，在局面变得毫无希望前让路由器舍弃负担。
> 

## 4.服务质量（资源预留，缓冲，抖动，漏桶算法，令牌桶）

网络层的服务质量包括如下几个方面：

- 可靠性：网络信息系统能够在规定条件下和规定的时间内完成规定的功能的特性。
- 延迟（delay）：数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总的时间。
- 抖动（jitter）：延迟的变化（即标准方差）或者数据包到达时间的变化。
- 带宽

资源预留主要包括三个部分：

- 带宽
- 缓冲区：又包括客户端缓冲数据包和服务端流量整形。
- CPU周期

### 流量整形

**流量整形（Traffic Shaping）**：调节进入网络的数据流的平均速率和突发性所采用的技术。漏桶算法和令牌桶是两个主要的流量整形技术。

**漏桶算法**：在每个主机连接到网络的接口都包含一个漏桶，即一个有限长度的内部队列。如果当队列满的时候，又有一个分组到来，则该分组被丢弃。每过一个常数时间才允许把一个分组放到网路上，这种机制可以将主机内用户进程发送出来的一个不均匀分组流变成了网络上一个均匀分组流，把突发分组流变得很平静，从而极大降低了拥塞的几率，而且无论负载突发性如何，漏桶算法都强迫输出按平均速率进行。

**令牌桶算法**：漏桶中保存的是令牌，这些令牌由时钟产生，每隔T产生一个。要使一个分组被传送出去，它必须抓住并销毁一个令牌，令牌桶允许将令牌即许可权保存起来，直至到达桶的最大尺寸n，当令牌桶满后，令牌桶丢弃令牌，不丢弃分组。从本质上讲，令牌桶所做的事情是：允许突发流量，但是不得超过一个预定的最大长度

> 令牌桶最大速率传输时间的计算：Ms=B+Rs（s最大速率传输时间，M最大传输速率，B桶的容量，R令牌的产生速率）
> 

二者的比较：

1. 流量整形策略不同：漏桶算法能够强行限制数据的传输速率，令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。
2. 丢弃对象不同：当令牌桶满了之后，令牌桶丢弃令牌，但是不丢弃分组，相反的，在漏桶算法中丢弃分组。

## 5.网络互联（隧道技术）

当两端网络使用相同的网络，**中间网络使用的一种封装技术**。在中间传输时使用新的协议头驱动，在两端网络传输时使用原有的协议头驱动。隧道技术是解决不同种类网络互联一个特例的方法，用于**解决发送和接收网络属于同一类型网络，但是中间经过不同类型网络的情况。**

![G3yWSs4JcBxrDbP.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645765.png)

**隧道技术（Tunneling）**：是一种通过**使用互联网络的基础设施在不同网络之间传递数据的方式**。使用隧道传递的数据（或负载）可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。新的帧头提供路由信息，以便通过互联网传递被封装的负载数据。

## 6.Internet（IPv4协议，IP地址结构，子网，子网掩码，子网换分，CIDR，地址聚合技术，NAT，ICMP，ARP寻址，DHCP，OSPF，BGP）

### IPv4

**IPv4帧结构**

![6VjcyLln3JZDU2u.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645191.png)

IPv4 帧分为头部和净荷载，头部占 20 - 60 字节，包含如下部分：

- Version：版本号。
- IHL：协议头部长度。
- Type Of Service：服务的类型，**后两位携带显式拥塞通知**。
- Total Length：总长度（最长65535字节）。
  
    > 以太网的最大传送单元MTU为1500字节，因此当一个IP数据报封装成帧时，数据报的总长度不能超过下面数据链路层的MTU值。
    > 
- Identification：标识分段是否属于同一个数据包。
- DF, Don't Fragment：不分段标识位，取0时允许分片。
- MF, More Fragment：更多的段，除数据包中最后一个段外，其余皆为1，表示后面还有分片。
- Fragment Offset：段偏移（最多8192个段），占13位。以8个字节为偏移单位，因此每个分片的长度一定是8字节（64位）的整数倍。
- Time to Live：生命周期（255秒），即数据报在网络中可通过的路由器数的最大值。路由器在转发分组之前，先把TTL减1，若TTL被减为0，则该分组必须丢弃。
- Protocol：传输层使用的协议，即分组的数据部分应该交给哪个传输层协议，TCP为6，UDP为17。
- Header Checksum：头部校验和。
- Source Address、Destination Address。
- Options。

**IP地址**

IPv4地址由网络号和主机号构成，共32位，一般使用十进制表示法。

按照网络号的前八位进行划分，总共有5类网络：

- A类：0～127：保留给政府机构。
  
    > 10.X.X.X 是私有地址，范围 10.0.0.0 - 10.255.255.255。
    > 
- B类：128～191：分配给中等规模的公司。
  
    > 私有地址范围是 172.16.0.0—172.31.255.255
    > 
- C类：192～223：分配给任何需要的人。
  
    > 范围 192.168.0.0—192.168.255.255。
    > 
- D类：224～239，组播地址。
- E类：240～254，保留为研究测试使用。
  
    ![MSDTdp8gNbwcZ7K.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645561.png)
    

一些特殊的IP地址：

1. 0.0.0.0 表示本网络上的本主机。
2. 255.255.255.255 限制广播地址，这个地址不能被路由器转发。
3. 127.0.0.0 保留作为环路自检地址，此地址表示任意主机本身，目的地址为环回地址的IP数据报永远不会出现在任何网络上。
4. 主机号全为0表示网络本身。比如在192.168.0.0/24的子网中，192.168.0.0表示这个子网本身。
5. 主机号全为1表示本网络的广播地址。比如，在 192.168.0.0/24 的子网中，192.168.0.255 表示这个子网的广播地址。
   
    > 因此在计算子网中的主机数量能承载多少个的时候需要减去2(全0表示网络,全1表示广播)
    > 

**子网掩码**是一种用来指明一个IP地址的哪些位标识的是主机所在的网络地址以及哪些位标识的是主机地址的位掩码

### CIDR无类域间路由&子网划分

无类域间路由（CIDR）是在变长子网掩码的基础上提出的一种消除 A，B，C 类网络划分，并且可以在软件的支持下实现构造超网的一种IP地址的划分方法.

其原理包含两部分：

- 聚合：将子网网络号最大公共部分聚合为新的网络号。
- 转发：将目的地址分别于路由表中的每一项网络号的子网掩码进行比对，选择最长匹配的网络表项进行转发。

CIDR是将原本的主机号取出一部分，用来作为对原本网络号的进一步分类，也就是所谓的子网号，这样便在一个网络下面通过主机号的某些位区分出了新的子网。

> 例如，原本`192.168.0.0`是一个B类网络，我们可以定义`192.168.1.0`为他的一个子网，只能容纳254（除去网络地址和广播地址）台主机。
> 

子网掩码表示其实就是,子网掩码和IP地址**与操作**计算出对应的网络号，并将主机号全部抹0，如下图所示：

![8pCUyaVz3mqvdn1.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645176.png)

**路由聚合**（Route Aggregation）指把多个小前缀的地址块合并成一个大前缀的地址块的过程。

**最长前缀匹配**（最佳匹配）是指使用CIDR时，路由表中的每个项目由“网络前缀”和“下一跳”组成。在查找路由表时可能会得到不止一个匹配结果，应当从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，其地址块就越小，因为路由就越具体。

### NAT网络地址转换

NAT技术通过将专用网络地址转换为公用地址，从而对外隐藏了内部管理的IP地址。

NAT有这些特点：

- 解决了IP地址短缺问题。解决策略:
    1. 动态分配IP
    2. 迁移到IPv6
    3. 多台主机共用一个 IP。
- NAT的思想是设定两套IP地址，内网相对于外网来说共用一个public地址；而在内网中，每台机器对应一个private 地址。
- 内网之间的通信使用 private 地址，当想要向外网发送消息时，只需将源地址替换为内网共用的 public 地址。
- 当外网向内网发送消息时，因无法区分内网的主机，所以引入了 port。将**私有IP与端口号影射成新的port，当与这个端口号交互时，根据影射算法可以知道私有IP**。

NAT存在的问题：

1. NAT违反了IP的结构模型，多个主机可以使用一个IP地址。
2. NAT将Internet从一个无连接网络变成一个面向连接网络特有的形式。
3. 违反了最基本的协议分层原则，传输层的数据不再对网络层透明。
   
    > NAT技术在转换过程中会修改数据包的源IP地址、目的IP地址、源端口号和目的端口号等信息。这种修改操作会影响到传输层对网络层数据的处理，使得传输层对网络层的数据不再透明。
    > 
4. 一旦进程不适用TCP或UDP协议，NAT将无法准确定位。
5. 端口号是16位的，所以最多可以将 65,536 台机器映射到一个IP地址上。

NAT 工作时，出境数据包进入NAT盒子后，其源地址被客户的真实IP地址取代，而且TCP的源端口号字段被一个索引值取代，该索引是NAT盒子的地址转换表中 65536 个表项中的一个，该表项包含了原来的IP地址和原来的端口号，重新计算IP头和TCP头的校检和，并将校检和插入数据包中；入境的一个数据包到达NAT盒子时，源端口取出作为索引值找到内部的IP地址和原来的端口号，插入数据包，重新计算IP头和TCP头的校检和，插入到数据包。

![8jdQio2aPK5VcFw.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645657.png)

### 因特网控制协议

主要的因特网控制协议有ICMP、ARP、DHCP、RIP、OSPF和BGP协议。

**Internet控制消息协议（ICMP）**：向数据包源端报告有关事件。每一种ICMP消息类型都被封装在一个IP分组中，允许主机或者路由器来报告差错和异常情况 ：

- 目的地不可达（DF，“小数据包网络”）。
- 超时（TTL为零）。
- 参数问题，无效的头域。
- 源端抑制：抑制分组。
- 重定向：告诉路由器有关地理信息。

**ARP，Address Resolution Protocol（广播协议）**：地址解析协议。用于完成IP地址到MAC地址的映射。请求和应答：使用地址解析协议（IP->MAC地址的映射）。

工作的过程：

1. IP层协议通过目标机器的IP地址和自己的子网掩码，检查它跟自己是否属同一网络。
2. 如果属于同一网络，就直接在本网络内查找这台机器的MAC。检查ARP高速缓存，如果以前两机有过通信，在A机的ARP缓存表应该有B机IP与其MAC的映射关系，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，则同一局域网所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存。
3. 如果IP协议通过计算发现目标地址与自己不在同一网段内，就直接将交由路由处理，也就是将路由的MAC取过来，至于怎样得到路由的MAC：先在ARP缓存表找，找不到可以利用广播。路由得到这个数据帧后，再跟目标主机进行联系，如果找不到，就向主机A返回一个超时的信息。
4. 如果发送的IP地址不在本局域网上则发送给默认网关（默认网关：默认网关具有网络上的最低地址（是路由器的IP地址））。
   
    ![EI2Kta9BrVJZysn.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645167.png)
    

ARP 是解决**同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题**。如果要找的这个主机和源主机不在同一个局域网上，那么就要通过ARP协议找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络，剩下的工作就由下一个网络来做。

ARP的两个优化：

- 缓存。
- 每个新主机开机时广播。

代理ARP：

- 路由器不转发以太网级别的广播信息
- 主机将发往其他网络的广播信息发送给本地代理

反向地址解析协议（RARP）：将MAC映射到IP地址，只是ARP反过来罢了。缺点：目标地址全1，路由器不转发

ARP、RARP都是广播协议——网络上的每一台机器都能收到请求。

BOOTP（bootstrap）：使用UDP数据报，路由器转发。缺点：新机器加入，需要手动配置（MAC，IP）

**DHCP，Dynamic Host Configuration Protocol（动态主机配置）协议**：计算机启动时向 DHCP服务器请求 IP 地址，DHCP 服务器给主机分配一个空闲的 IP 地址。服务器用MAC地址标识该主机。

### 路由选择协议

自治系统（AS，Autonomous System）：**有权自主地决定在本系统中应采用何种路由协议的小型单位**。

根据路由选择/网关协议的工作环境，可以分为两种协议：

- **内部网关协议（Interior Gateway Protocol，IGP）**：在一个自治系统内部使用的路由选择协议，它与互联网中其他自治系统选择什么路由选择协议无关。
- **外部网关协议（Border Gateway Protocol，BGP）**：用于连接自治域。是一种外部网关路由协议。是一种**改进了的距离矢量路由协议**，保存完整的路由信息。
  
    > BGP 的关键作用是尊重网络的政策约束(考虑政治约束)。
    > 

对于BGP来讲通常只有一种常用的路径矢量算法；IGP协议则更多一些，包括各种私有协议以及常见的RIP协议和OSPF协议：

- **路由信息协议（RIP，Routing Information Protocol）**：使用距离矢量算法的协议。
- **OSPF协议**：开放的最短路径优先协议，是一种常用的内部网关协议，属于链路状态路由协议的一种。
  
    ![vpBfkcKiM6GUZjT.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281645306.png)
    

# 传输层

传输层提供**应用进程之间的逻辑通信（即端到端的通信）**。与网络层的区别是，网络层提供的是主机之间的逻辑通信。

**复用和分用**：复用是指发送方不同的应用进程都可以使用同一个传输层协议传送数据；分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。

> 传输层的复用分用功能与网络层的不同，网络层的复用是指发送方不同的协议的数据都可以封装成IP数据报发送出去，分用是指接收方的网络层在剥去首部后把数据交付给相应的协议。
> 

传输层要对收到的报文进行**差错检测（首部和数据部分）**，而网络层只检查 IP 数据报的首部，不检验数据部分是否出错。

传输层提供两种不同的传输协议：**面向连接的TCP**和**无连接的UDP**。而网络层无法同时实现两种协议（即网络层要么只提供面向连接的服务，如虚电路；要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式）。

**端口（Port）**：应用层的各种协议进程与传输实体进行层间交互的一种地址，应用进程通过**端口号**进行标识，长度为16bit。端口能够让**应用层的各种应用进程将其数据通过其端口向下交付给传输层**，以及让传输层指导应当将其报文段中的数据向上通过端口交付给应用层相应的进程。

## 1.传输协议要素（寻址，三次握手建立连接/释放连接，流控制和缓冲）

### 寻址

### 建立与释放链接三次握手

![vM7Yfn1EkDu5TAd.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281646415.png)

如上图所示，这是建立连接的三种情况：

1. 图6-1是正常的三次握手建立连接的过程。
2. 图6-2这种情况是老的CR（Connection Request）重复分组出现了，它虽然引起了主机2发送相应的分组，但是主机1根据主机2发送分组的 ack 值可以发现这是异常情况， 所以拒绝（REJECT）。
3. 图6-3这种情况是老的CR （Connection Request）重复分组和和老的数据重复分组出现的情况。虽然老的CR重复分组引起了主机2发送相应的分组，但是主机1根据主机2 发送分组的 ack 值可以发现这是异常情况，产生拒绝（REJECT）；对于数据重复分组。主机 2根据分组的 ack 值可以发现这是异常情况。

对于断开链接:

![VsYlZ1fa3KgtMAi.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281646240.png)

![Nm9kPT4D7gvdARY.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281646088.png)

如上图所示，断开连接的四种情况：

1. 图 6-4 是正常的三次握手断开连接的过程。
2. 图 6-5 这种情况是最后主机 1 发出的 ack 丢失的情况，这时候，当主机 2 的计时器超时后，主机 2 就会释放连接。
3. 图 6-6 这种情况是主机 2 给主机 1 的 DR（Disconnection Request）的应答丢失了，这种情况下，当主机 1 的计时器超时后，主机 1 会重新发送 DR。
4. 图 6-7 这种情况是主机 2 给主机 1 的 DR（Disconnection Request）的应答和主机 1 后续的 DR 都丢失了，这种情况下，主机 1 经过 N 次重传之后，就会放弃，并且释放连接；而主机 2 在计时器超时之后也会释放连接。

### 流控制和缓冲

见上文中关于流量整形与缓冲区的概念

## 2.UDP

UDP（User Datagram Protocol），用户数据报协议。

UDP的优点：

1. UDP无需建立连接。因此UDP不会引入建立连接的时延。
2. 无连接状态。不需要维护连接状态。
3. 分组首部开销小。TCP有20字节的首部开销，UDP只有8字节。
4. 应用层能更好地控制要发送的数据和时间。UDP没有拥塞控制，因此网络中的拥塞不会影响主机的发送效率。
   
    ![38ac56057a61585d809ce92367e7738d.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281646543.png)
    

UDP常用于一次性传输比较少量的网络应用，如DNS。UDP也常用于多媒体应用，如IP电话，实时视频会议等。可靠数据传输对于这些应用来说并不是最重要的，但是TCP的拥塞控制会导致数据出现大的延迟，这是不可容忍的。

UDP提供尽最大努力的交付，但并不意味应用对数据的要求不可靠，因此所有的维护传输可靠性的工作需要用户在应用层完成。

**UDP是面向报文的**。UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，既不合并，也不拆分，而是保留这些报文的边界；接收方UDP对IP层交上来的UDP数据报，在去除首部后就原封不动地交给上层应用进程，和一次交付一个完整的报文。

UDP检验：二进制反码求和再取反。(加上伪首部)

## 3.TCP（TCP服务模型，TCP协议，TCP连接建立，TCP连接释放，TCP滑动窗口，Nagle‘s，蠢笨窗口综合症，TCP拥塞控制，slow start)

### TCP协议

TCP（Transmission Control Protocol）：传输控制协议，在不可靠的IP层之上**实现**的可靠的数据传输协议。

TCP的特点：

1. TCP是面向连接的传输层协议。
2. 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一的）。
3. TCP提供可靠的交付服务，保证传送的数据无差错、不丢失、不重复且有序。
4. TCP提供全双工通信，允许通信双方的应用进程在任何时候都发送数据，为此TCP连接的**两端都设有发送和接受缓存**，用来临时存放双方通信的数据。
    - 发送缓存：发送应用程序传给发送方TCP准备发送的数据；TCP已经发送但是没有接收到确认的数据。
    - 接收缓存：按序到达但尚未被接收应用程序读取的数据；不按序到达的数据。
5. **TCP是面向字节流的**

![msMphDiFPye7XOW.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281646003.png)

1. 第一行是源端口（Source port）和目标端口（Destination port）信息。
2. 第二行是序列号（Sequence number），表示此次发送数据的第一个字节的编号第三行是确认号（Acknowledge number），表示下次想要接收数据的第一个字节的编号。
3. 第四行由几个部分组成：
    - TCP 头长度（TCP header length），它占4位， 单位是“4字节”，所以我们可以简单计算一下：24*4B=64B（其中有20B 是TCP数据段的头的固定长度，另外 44B 是可选项 Options）。
    - 未使用的4位域。
    - 8个1位标志：CWR 和 ECE 用作拥塞控制的信号、URG 置1表示使用了紧急指针、 ACK 置1表示确认号字段是有效的、PSH位表示这是带有PUSH 标志的数据、RST 位被用于重置一个己经混乱的连接（一般而言，如果得到的数据段被设置了 RST 位，那说明你这一端有了问题）、SYN被用于建立连接的过程、FIN 被用于释放一个连接。
    - 窗口大小（Window size），它表示这个 TCP 数据段发送方当前可用的缓冲区大小，表示的是这一方的接收能力。
4. 第五行由两部分组成：第一部分是校验和（Checksum），它校验的范围包括TCP 数据段的头部、数据以及**伪TCP头**。
5. 第六行是 Options。

TCP的校验和需要使用伪TCP头计算，伪TCP头如下图所示：

![A1S2Ey7UhnqG3tV.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281646371.png)

伪 TCP 头的第一行是源地址(IP)，第二行是目标地址(IP)，第三行由三部分组成：8位`0`，TCP 的协议号（6）以及TCP 数据段（包括TCP 头）的字节计数

### TCP链接维护与解除

建立链接:三次握手

![Vo3XMyDtQ9nT5zR.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281646069.png)

1. 客户机的TCP 首先向服务器的 TCP 发送一个连接请求报文。这个特殊的报文段**不含应用层数据**，但会消耗一个序号。`SYN=1`。客户机随机选择一个起始序号 `seq=x`。
2. 服务器的 TCP 收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该 TCP 连接分配 TCP 缓存和变量。在确认报文段中，`SYN=1`，`ACK=1`， `ack=x+1`，并且服务器随机产生起始序号 `seq=y`，确认报文同样不包含应用层数据。
3. 当客户机收到确认报文后，还要向服务器发出确认，同时也要给该连接分配缓存和变量。`ACK=1`，`seq=x+1`，`ack=y+1`。该报文可以携带数据，如果**不携带数据就不消耗序号**。

释放连接过程由四次挥手组成，如果将2、3次挥手进行捎带的话也可以实现三次挥手释放连接。连接释放过程如下:

![3aQH7CNgVctUDvh.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281646131.png)

1. 客户机打算关闭连接，就向其 TCP 发送一个连接释放报文段，并停止再发任何数据，主动关闭 TCP 连接，该报文段的 `FIN=1`，`seq=u`，它等于前面已传送过的数据的最后一个字节的序号加一（FIN 报文段即使不携带任何数据，但也要消耗掉一个序号）。TCP 是全双工的，即可以想象成一条 TCP 上有两条数据通路。当发送 FIN 报文时，发送 FIN 的一端就不能再发送数据，也就是关闭了其中的一条数据通路，但是对方还可以发送数据。
2. 服务器接收到连接释放报文段后即发出确认，确认号是 `ack=u+1`，而这个报文段自己的序号是 `v`，等于它前面传送过的数据的最后一个字节的序号加 1。此时，从客户及到服务器这个方向的连接就释放了，TCP 连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接仍未关闭。
3. 若服务器已经没有要向客户机发送的数据，就通知 TCP 释放连接，此时发出 `FIN=1`，`ACK=1`，`seq=w`，`ack=u+1` 的连接释放报文段。
4. 客户机收到连接释放报文段后，必须发出确认。在确认报文段中，`ACK=1`，确认号 `ack=w+1`，序号 `seq=u+1`。此时 TCP 连接还没释放掉，必须经过时间等待计时器设置的时间 2MSL 后，A 才进入到连接关闭状态。

TCP提供的**可靠数据传输服务**就是要保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。TCP使用了**校验、序号、确认和重传**等机制来达到这个目的：

- 序号：TCP连接中传送的数据流的**每一个字节都要编上一个序号**。**序号字段的值则指的是本报文段发送的数据的第一个字节的序号**。
- 确认：TCP首部的**确认号是期望收到对方的下一个报文段的数据的第一个字节的序号**。TCP使用累计确认，即TCP只确认数据流中至第一个丢失字节为止的字节。
- 重传：超时和冗余ACK会导致重传。
    1. 超时：TCP每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到期但还没有收到确认，就重传这一报文段。TCP采用一种自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差叫做报文段的往返时间（RTT）。
    2. 冗余ACK：TCP规定每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。TCP规定当发送方收到对同一个报文段的3个冗余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。这时可以立即对丢失的报文段进行重传，这种技术成为快速重传。

### TCP流量控制

TCP 提供一种基于滑动窗口协议的流量控制机制。在通信过程中，接收方(B)根据自己**接收缓存的大小**，动态地调整发送方(A)A的发送窗口大小，这就是**接受窗口** `rwnd`，即调整 TCP 报文段首部中的“窗口”字段值，来限制发送方向网络注入报文的速率。

同时，发送方根据其对当前网络拥塞程度的估计而确定的窗口值，称为**拥塞窗口** `cwnd`，其大小与网络的带宽和时延密切相关。

发送方的发送窗口的实际大小是取 `rwnd` 和 `cwnd` 中的最小值。

![Wh6J3NZw2Q4SYTK.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281646639.png)

上图中接收方B在传输过程中稍带发送了B接收窗口大小,因此发送方A的发送窗口大小就是从`ack`到`ack+rwnd-1`之间的字节数据.

而这种控制方式会因为传输问题(丢失)而发生死锁,如下图所示如果上一次确认接收窗口为0,但更新的报文丢失,那么发送发持续不发送数据,接收方没接受到数据自然也不会返回确认,也不会有稍带的rwnd

![6J3lDGSKdk7bCYH.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281646292.png)

因此发送方需要定时发送零窗口探测报文,接收方返回rwnd大小来打破死锁

### TCP拥塞控制

TCP 协议中主要的拥塞控制为**慢启动协议**和**拥塞避免协议**，进一步的，还有**快速重传**和**快速恢复协议**。

TCP 刚刚连接好，先令拥塞窗口 `cwnd=1`，即一个最大报文段长度 `MSS`。使用慢开始算法后，每经过一个传输轮次（即往返时延 `RTT`），拥塞窗口 `cwnd` 就会加倍，即 `cwnd` 的大小呈指数形式增长。这样慢开始一直把拥塞窗口增大到一个规定的慢开始门限，然后改用拥塞避免算法。

拥塞避免算法的做法是：发送端的拥塞窗口 `cwnd` 每经过一个往返时延 RTT 就增加**一个**MSS 的大小而不是加倍，使 `cwnd` 按线性规律缓慢增长（即**加法增大**），而当出现一次超时（网络拥塞），则令**慢开始门限**等于当前 `cwnd` 的一半（即**乘法减小**）。

![拥塞控制过程示意图](https://s2.loli.net/2024/01/07/QOsv7nKx5XadgGY.png)

当网络出现拥塞时，无论在慢开始阶段还是拥塞避免阶段，只要发送方检测到超时事件的发生（没有按时收到确认，重传计时器超时），就把**慢开始门限**设置为出现拥塞时的发送方 cwnd 的一半（但不能小于 2）。然后把拥塞窗口 cwnd 重设为 1，执行慢启动算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

## 4.UDP&TCP对比

在详细讨论 UDP 和 TCP 时，二者常被提及的一个特点就是 UDP 面向报文、TCP面向字节流

![43yBxTq9klsMbvD.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281646571.png)

可以看到：

- UDP 只是对上层报文添加了 Header，所以是面向应用报文的传输。
- TCP 会将上层数据以字节为单位保存在缓冲区中，并按照一定规则选择其中的数据进行发送，因此 TCP 的操作都是以字节流为基础，这也是 TCP 能够实现拥塞控制、可靠传输等特性的原因。

在提供的服务上，UDP 提供了无连接不可靠的传输服务，TCP则是面向连接的可靠传输服务.

在头部结构上二者具有显著的区别：

![BHCKq1YoA2v7ucm.png](https://kyrie-figurebed.oss-cn-beijing.aliyuncs.com/img/Horizon/202412281646580.png)

# 应用层

## 1.DNS

**DNS（Domain Name System）域名系统**是因特网使用的命名系统，用来把便于人们记忆的含有特定含义的主机名转换为便于机器处理的 IP 地址。

DNS 系统采用客户/服务器模型，其协议运行在 UDP 之上，使用 53 端口；分为 3 部分：层次域名空间、域名服务器、解析器。

域名解析有两种方式：**递归**和**迭代**。

某客户机想知道域名为 [y.abc.com](http://y.abc.com/) 主机的 IP 地址的解析过程：

1. 客户机向其**本地域名服务器**发出 DNS 请求报文。
2. 本地域名服务器收到请求后，查询本地缓存，假设没有该记录，则以 DNS 客户的身份向**根域名服务器**发出解析请求。
3. 根域名服务器收到请求后，[判断该域名属于.com](http://xn--6kq30g6xb01gq0gp7p286d.com/) 域，则将对应的**顶级域名服务器** [dns.com](http://dns.com/) 的 IP 地址返回给本地域名服务器。
4. 本地域名服务器向顶级域名服务器 [dns.com](http://dns.com/) 发送解析请求报文。
5. 顶级域名系统 [dns.com](http://dns.com/) 收到请求后，判断该域名属于 [abc.com](http://abc.com/) 域，故将对应的**授权域名服务器** [dns.abc.com](http://dns.abc.com/) 的 IP 地址返回给本地域名服务器。
6. 本地域名服务器向授权域名服务器 [dns.abc.com](http://dns.abc.com/) 发送解析请求报文。
7. 授权域名服务器 [dns.abc.com](http://dns.abc.com/) 收到请求后，将查询结果返回给本地域名服务器。
8. 本地域名服务器将查询结果保存到本地缓存，同时返回给客户机。
